/*
     File        : file.C

     Author      : Riccardo Bettati
     Modified    : 2017/05/01

     Description : Implementation of simple File class, with support for
                   sequential read/write operations.
*/

/*--------------------------------------------------------------------------*/
/* DEFINES */
/*--------------------------------------------------------------------------*/

    /* -- (none) -- */

/*--------------------------------------------------------------------------*/
/* INCLUDES */
/*--------------------------------------------------------------------------*/

#include "assert.H"
#include "console.H"
#include "file.H"

/*--------------------------------------------------------------------------*/
/* CONSTRUCTOR */
/*--------------------------------------------------------------------------*/
unsigned int File::random = 0;
FileSystem* File::file_system = 0;


File::File() {
    /* We will need some arguments for the constructor, maybe pointer to disk
     block with file management and allocation data. */
    Console::puts("In file constructor.\n");
    //assert(false);
  	position = block = 0;
        file_id = random; random ++;
        bool found = file_system->CheckFile(file_id);

        /* If not found already and able to create */
        if(!found && file_system->CreateFile(file_id)) {
                size = 0;
                start_block = 0;
}


}

/*--------------------------------------------------------------------------*/
/* FILE FUNCTIONS */
/*--------------------------------------------------------------------------*/

int File::Read(unsigned int _n, char * _buf) {
    Console::puts("reading from file\n");
    //assert(false);

if(_n==0 || EoF() || size == 0)	return 0;

        /*
          I will assume that I can read at most 512 bytes */
        
        unsigned char temp_buffer[FILESYSTEM_BLOCK_SIZE];
        unsigned int char_read = 0; /* How many chars I have read */
		
        while(_n) {

                file_system->filesystem_disk->read(block, temp_buf);
			
                unsigned int offset = position % 508;
                /* minimum of _n and available bytes in block and size - position */
                unsigned int data_read;
                if (_n > 508 - offset)
                        data_read = 508 - offset;
                else
                        data_read = _n ;
                
                /* Cant to more than I have */
                if(data_read > size - position)
                        data_read = size - position;
                
                memcpy(_buf + char_read, temp_buf + offset, data_read);

                /* Update the variables */
                char_read += data_read;
                _n -= data_read;
                position += data_read;

                /* if I am done with the block, move to the next one */
                if((position % 508 == 0) && !EoF()) {
                        file_system->filesystem_disk->read(block, temp_buf);
                        memcpy(&block, temp_buf+508, 4);
                }
        }
		
return char_read;

}


void File::Write(unsigned int _n, const char * _buf) {
    Console::puts("writing to file\n");
    //assert(false);
  //if(_n == 0) return 0;

        unsigned char temp_buf[512];
        unsigned int char_written = 0;
		
        while(_n) {

                /* Similar proceedure as read () */
                unsigned int offset = position % 508;
                file_system->filesystem_disk->read(block, temp_buf);
                unsigned int data_write;
                if (_n > 508 - offset)
                        data_write = 508 - offset;
                else
                        data_write = _n ;
                memcpy(temp_buf + offset, _buf + char_written, data_write);
                file_system->filesystem_disk->write(block, temp_buf);

                /* Make sure that size is updated */
                if(data_write + position > size)
                        size = position + data_write;

                /* Now update the common variables */
                char_written += data_write;
                _n -= data_write;
                position += data_write;

                /* Do I need to switch to next block ? */
                if((position % 508 == 0) && !EoF()) {
                        file_system->filesystem_disk->read(block, temp_buf);
                        memcpy(&block, temp_buf+508, 4);
                }
        }
        /*
          flush it */
//return char_written;

}

void File::Reset() {
    Console::puts("reset current position in file\n");
    //assert(false);
    position = 0;
block = start_block;
}

void File::Rewrite() {
    Console::puts("erase content of file\n");
    //assert(false);
  	position = 0;
        block = 0;

        unsigned char temp_buf[512];
        unsigned int temp_block = start_block;
        unsigned int next_block = 0;

        /* Do for all blocks */
        while(1) {
                /* If done */
                if((int)block == -1) {
                        break;
                }

                /* Read and copy */
                file_system->filesystem_disk->read(temp_block, temp_buf);
                memcpy(&next_block, temp_buf+508, 4);

                /* Copy and write */
                memcpy(temp_buf+508, &(file_system->filesystem_free_block), 4);
                file_system->filesystem_disk->write(temp_block, temp_buf);

                file_system->filesystem_free_block = temp_block;

                /* Go to the next block */
                temp_block = next_block;
        }
        
        /* Reset the variables */
        start_block = 0;
size = 0;

 Console::puts("erase content of file is done \n");

}


bool File::EoF() {
    Console::puts("testing end-of-file condition\n");
    //assert(false);

return size == position;
}
